import { entityKind } from "../entity.js";
import {
  PgDeleteBase,
  PgInsertBuilder,
  PgSelectBuilder,
  PgUpdateBuilder,
  QueryBuilder
} from "./query-builders/index.js";
import { WithSubquery } from "../subquery.js";
import { RelationalQueryBuilder } from "./query-builders/query.js";
import { PgRefreshMaterializedView } from "./query-builders/refresh-materialized-view.js";
import { SelectionProxyHandler } from "../selection-proxy.js";
class PgDatabase {
  constructor(dialect, session, schema) {
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap } : { schema: void 0, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(
          schema.fullSchema,
          this._.schema,
          this._.tableNamesMap,
          schema.fullSchema[tableName],
          columns,
          dialect,
          session
        );
      }
    }
  }
  static [entityKind] = "PgDatabase";
  query;
  $with(alias) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        return new Proxy(
          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  with(...queries) {
    const self = this;
    function select(fields) {
      return new PgSelectBuilder({
        fields: fields ?? void 0,
        session: self.session,
        dialect: self.dialect,
        withList: queries
      });
    }
    return { select };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table) {
    return new PgUpdateBuilder(table, this.session, this.dialect);
  }
  insert(table) {
    return new PgInsertBuilder(table, this.session, this.dialect);
  }
  delete(table) {
    return new PgDeleteBase(table, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  execute(query) {
    return this.session.execute(query.getSQL());
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}
const withReplicas = (primary, replicas, getReplica = () => replicas[Math.floor(Math.random() * replicas.length)]) => {
  const select = (...args) => getReplica(replicas).select(args);
  const selectDistinct = (...args) => getReplica(replicas).selectDistinct(args);
  const selectDistinctOn = (...args) => getReplica(replicas).selectDistinctOn(args);
  const $with = (...args) => getReplica(replicas).with(args);
  const update = (...args) => primary.update(args);
  const insert = (...args) => primary.insert(args);
  const $delete = (...args) => primary.delete(args);
  const execute = (...args) => primary.execute(args);
  const transaction = (...args) => primary.transaction(args);
  const refreshMaterializedView = (...args) => primary.refreshMaterializedView(args);
  return new Proxy(
    {
      ...primary,
      update,
      insert,
      delete: $delete,
      execute,
      transaction,
      refreshMaterializedView,
      $primary: primary,
      select,
      selectDistinct,
      selectDistinctOn,
      with: $with
    },
    {
      get(target, prop, _receiver) {
        if (prop === "query") {
          return getReplica(replicas).query;
        }
        return target[prop];
      }
    }
  );
};
export {
  PgDatabase,
  withReplicas
};
//# sourceMappingURL=db.js.map