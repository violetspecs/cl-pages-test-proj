import { entityKind } from "../entity.cjs";
import type { PgDialect } from "./dialect.cjs";
import { PgDeleteBase, PgInsertBuilder, PgSelectBuilder, PgUpdateBuilder, QueryBuilder } from "./query-builders/index.cjs";
import type { PgSession, PgTransaction, PgTransactionConfig, QueryResultHKT, QueryResultKind } from "./session.cjs";
import type { PgTable } from "./table.cjs";
import type { TypedQueryBuilder } from "../query-builders/query-builder.cjs";
import type { ExtractTablesWithRelations, RelationalSchemaConfig, TablesRelationalConfig } from "../relations.cjs";
import type { ColumnsSelection, SQLWrapper } from "../sql/sql.cjs";
import { WithSubquery } from "../subquery.cjs";
import type { DrizzleTypeError } from "../utils.cjs";
import type { PgColumn } from "./columns/index.cjs";
import { RelationalQueryBuilder } from "./query-builders/query.cjs";
import { PgRefreshMaterializedView } from "./query-builders/refresh-materialized-view.cjs";
import type { SelectedFields } from "./query-builders/select.types.cjs";
import type { WithSubqueryWithSelection } from "./subquery.cjs";
import type { PgMaterializedView } from "./view.cjs";
export declare class PgDatabase<TQueryResult extends QueryResultHKT, TFullSchema extends Record<string, unknown> = Record<string, never>, TSchema extends TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>> {
    static readonly [entityKind]: string;
    readonly _: {
        readonly schema: TSchema | undefined;
        readonly tableNamesMap: Record<string, string>;
    };
    query: TFullSchema extends Record<string, never> ? DrizzleTypeError<'Seems like the schema generic is missing - did you forget to add it to your DB type?'> : {
        [K in keyof TSchema]: RelationalQueryBuilder<TSchema, TSchema[K]>;
    };
    constructor(
    /** @internal */
    dialect: PgDialect, 
    /** @internal */
    session: PgSession<any, any, any>, schema: RelationalSchemaConfig<TSchema> | undefined);
    $with<TAlias extends string>(alias: TAlias): {
        as<TSelection extends ColumnsSelection>(qb: TypedQueryBuilder<TSelection, unknown> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection, unknown>)): WithSubqueryWithSelection<TSelection, TAlias>;
    };
    with(...queries: WithSubquery[]): {
        select: {
            (): PgSelectBuilder<undefined>;
            <TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection, "db">;
        };
    };
    select(): PgSelectBuilder<undefined>;
    select<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;
    selectDistinct(): PgSelectBuilder<undefined>;
    selectDistinct<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;
    selectDistinctOn(on: (PgColumn | SQLWrapper)[]): PgSelectBuilder<undefined>;
    selectDistinctOn<TSelection extends SelectedFields>(on: (PgColumn | SQLWrapper)[], fields: TSelection): PgSelectBuilder<TSelection>;
    update<TTable extends PgTable>(table: TTable): PgUpdateBuilder<TTable, TQueryResult>;
    insert<TTable extends PgTable>(table: TTable): PgInsertBuilder<TTable, TQueryResult>;
    delete<TTable extends PgTable>(table: TTable): PgDeleteBase<TTable, TQueryResult>;
    refreshMaterializedView<TView extends PgMaterializedView>(view: TView): PgRefreshMaterializedView<TQueryResult>;
    execute<TRow extends Record<string, unknown> = Record<string, unknown>>(query: SQLWrapper): Promise<QueryResultKind<TQueryResult, TRow>>;
    transaction<T>(transaction: (tx: PgTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>, config?: PgTransactionConfig): Promise<T>;
}
export type PgWithReplicas<Q> = Q & {
    $primary: Q;
};
export declare const withReplicas: <HKT extends QueryResultHKT, TFullSchema extends Record<string, unknown>, TSchema extends TablesRelationalConfig, Q extends PgDatabase<HKT, TFullSchema, TSchema>>(primary: Q, replicas: [Q, ...Q[]], getReplica?: (replicas: Q[]) => Q) => PgWithReplicas<Q>;
