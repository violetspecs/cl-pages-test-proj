"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var db_exports = {};
__export(db_exports, {
  BaseSQLiteDatabase: () => BaseSQLiteDatabase,
  withReplicas: () => withReplicas
});
module.exports = __toCommonJS(db_exports);
var import_entity = require("../entity.cjs");
var import_query_builders = require("./query-builders/index.cjs");
var import_subquery = require("../subquery.cjs");
var import_query = require("./query-builders/query.cjs");
var import_raw = require("./query-builders/raw.cjs");
var import_selection_proxy = require("../selection-proxy.cjs");
class BaseSQLiteDatabase {
  constructor(resultKind, dialect, session, schema) {
    this.resultKind = resultKind;
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap } : { schema: void 0, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new import_query.RelationalQueryBuilder(
          resultKind,
          schema.fullSchema,
          this._.schema,
          this._.tableNamesMap,
          schema.fullSchema[tableName],
          columns,
          dialect,
          session
        );
      }
    }
  }
  static [import_entity.entityKind] = "BaseSQLiteDatabase";
  query;
  $with(alias) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new import_query_builders.QueryBuilder());
        }
        return new Proxy(
          new import_subquery.WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
          new import_selection_proxy.SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  with(...queries) {
    const self = this;
    function select(fields) {
      return new import_query_builders.SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: self.session,
        dialect: self.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new import_query_builders.SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: self.session,
        dialect: self.dialect,
        withList: queries,
        distinct: true
      });
    }
    return { select, selectDistinct };
  }
  select(fields) {
    return new import_query_builders.SQLiteSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
  }
  selectDistinct(fields) {
    return new import_query_builders.SQLiteSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  update(table) {
    return new import_query_builders.SQLiteUpdateBuilder(table, this.session, this.dialect);
  }
  insert(into) {
    return new import_query_builders.SQLiteInsertBuilder(into, this.session, this.dialect);
  }
  delete(from) {
    return new import_query_builders.SQLiteDeleteBase(from, this.session, this.dialect);
  }
  run(query) {
    const sql = query.getSQL();
    if (this.resultKind === "async") {
      return new import_raw.SQLiteRaw(
        async () => this.session.run(sql),
        () => sql,
        "run",
        this.dialect,
        this.session.extractRawRunValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.run(sql);
  }
  all(query) {
    const sql = query.getSQL();
    if (this.resultKind === "async") {
      return new import_raw.SQLiteRaw(
        async () => this.session.all(sql),
        () => sql,
        "all",
        this.dialect,
        this.session.extractRawAllValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.all(sql);
  }
  get(query) {
    const sql = query.getSQL();
    if (this.resultKind === "async") {
      return new import_raw.SQLiteRaw(
        async () => this.session.get(sql),
        () => sql,
        "get",
        this.dialect,
        this.session.extractRawGetValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.get(sql);
  }
  values(query) {
    const sql = query.getSQL();
    if (this.resultKind === "async") {
      return new import_raw.SQLiteRaw(
        async () => this.session.values(sql),
        () => sql,
        "values",
        this.dialect,
        this.session.extractRawValuesValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.values(sql);
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}
const withReplicas = (primary, replicas, getReplica = () => replicas[Math.floor(Math.random() * replicas.length)]) => {
  const select = (...args) => getReplica(replicas).select(args);
  const selectDistinct = (...args) => getReplica(replicas).selectDistinct(args);
  const $with = (...args) => getReplica(replicas).with(args);
  const update = (...args) => primary.update(args);
  const insert = (...args) => primary.insert(args);
  const $delete = (...args) => primary.delete(args);
  const run = (...args) => primary.run(args);
  const all = (...args) => primary.all(args);
  const get = (...args) => primary.get(args);
  const values = (...args) => primary.values(args);
  const transaction = (...args) => primary.transaction(args);
  return new Proxy(
    {
      ...primary,
      update,
      insert,
      delete: $delete,
      run,
      all,
      get,
      values,
      transaction,
      $primary: primary,
      select,
      selectDistinct,
      with: $with
    },
    {
      get(target, prop, _receiver) {
        if (prop === "query") {
          return getReplica(replicas).query;
        }
        return target[prop];
      }
    }
  );
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BaseSQLiteDatabase,
  withReplicas
});
//# sourceMappingURL=db.cjs.map