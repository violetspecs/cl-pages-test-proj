import { entityKind } from "../entity.js";
import {
  QueryBuilder,
  SQLiteDeleteBase,
  SQLiteInsertBuilder,
  SQLiteSelectBuilder,
  SQLiteUpdateBuilder
} from "./query-builders/index.js";
import { WithSubquery } from "../subquery.js";
import { RelationalQueryBuilder } from "./query-builders/query.js";
import { SQLiteRaw } from "./query-builders/raw.js";
import { SelectionProxyHandler } from "../selection-proxy.js";
class BaseSQLiteDatabase {
  constructor(resultKind, dialect, session, schema) {
    this.resultKind = resultKind;
    this.dialect = dialect;
    this.session = session;
    this._ = schema ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap } : { schema: void 0, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(
          resultKind,
          schema.fullSchema,
          this._.schema,
          this._.tableNamesMap,
          schema.fullSchema[tableName],
          columns,
          dialect,
          session
        );
      }
    }
  }
  static [entityKind] = "BaseSQLiteDatabase";
  query;
  $with(alias) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder());
        }
        return new Proxy(
          new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true),
          new SelectionProxyHandler({ alias, sqlAliasedBehavior: "alias", sqlBehavior: "error" })
        );
      }
    };
  }
  with(...queries) {
    const self = this;
    function select(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: self.session,
        dialect: self.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new SQLiteSelectBuilder({
        fields: fields ?? void 0,
        session: self.session,
        dialect: self.dialect,
        withList: queries,
        distinct: true
      });
    }
    return { select, selectDistinct };
  }
  select(fields) {
    return new SQLiteSelectBuilder({ fields: fields ?? void 0, session: this.session, dialect: this.dialect });
  }
  selectDistinct(fields) {
    return new SQLiteSelectBuilder({
      fields: fields ?? void 0,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  update(table) {
    return new SQLiteUpdateBuilder(table, this.session, this.dialect);
  }
  insert(into) {
    return new SQLiteInsertBuilder(into, this.session, this.dialect);
  }
  delete(from) {
    return new SQLiteDeleteBase(from, this.session, this.dialect);
  }
  run(query) {
    const sql = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.run(sql),
        () => sql,
        "run",
        this.dialect,
        this.session.extractRawRunValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.run(sql);
  }
  all(query) {
    const sql = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.all(sql),
        () => sql,
        "all",
        this.dialect,
        this.session.extractRawAllValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.all(sql);
  }
  get(query) {
    const sql = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.get(sql),
        () => sql,
        "get",
        this.dialect,
        this.session.extractRawGetValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.get(sql);
  }
  values(query) {
    const sql = query.getSQL();
    if (this.resultKind === "async") {
      return new SQLiteRaw(
        async () => this.session.values(sql),
        () => sql,
        "values",
        this.dialect,
        this.session.extractRawValuesValueFromBatchResult.bind(this.session)
      );
    }
    return this.session.values(sql);
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}
const withReplicas = (primary, replicas, getReplica = () => replicas[Math.floor(Math.random() * replicas.length)]) => {
  const select = (...args) => getReplica(replicas).select(args);
  const selectDistinct = (...args) => getReplica(replicas).selectDistinct(args);
  const $with = (...args) => getReplica(replicas).with(args);
  const update = (...args) => primary.update(args);
  const insert = (...args) => primary.insert(args);
  const $delete = (...args) => primary.delete(args);
  const run = (...args) => primary.run(args);
  const all = (...args) => primary.all(args);
  const get = (...args) => primary.get(args);
  const values = (...args) => primary.values(args);
  const transaction = (...args) => primary.transaction(args);
  return new Proxy(
    {
      ...primary,
      update,
      insert,
      delete: $delete,
      run,
      all,
      get,
      values,
      transaction,
      $primary: primary,
      select,
      selectDistinct,
      with: $with
    },
    {
      get(target, prop, _receiver) {
        if (prop === "query") {
          return getReplica(replicas).query;
        }
        return target[prop];
      }
    }
  );
};
export {
  BaseSQLiteDatabase,
  withReplicas
};
//# sourceMappingURL=db.js.map